{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"树","date":"2022-05-05T12:54:38.145Z","updated":"2022-05-06T14:31:43.994Z","comments":true,"path":"api/articles/树.json","keywords":null,"cover":null,"content":"<h1 id=\"树形结构\"><a href=\"#树形结构\" class=\"headerlink\" title=\"树形结构\"></a>树形结构</h1><p>##前缀树（Trie）</p>\n<p>前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。</p>\n<p>前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针对于其他的例如平衡树或哈希表这种同样可以做到搜索字符串数据集中的单词的数据结构，Trie树可以做到：</p>\n<ol>\n<li>找到具有同一前缀的全部键值</li>\n<li>按字典序枚举字符串的数据集</li>\n</ol>\n<p>前缀树可以利用vector或者map存储结点内容，区别在于vector可能会浪费空间，但是执行较快；map内存管理灵活，但是速度略慢。</p>\n<p>节点的内容信息可以包括你所需要的字符串元素，一般来说是26个英文字母，当然你可以自行增添。为了确定该单词是否已经结束输入，我们增加一个isEnd的布尔类型变量来标识。</p>\n<p>以下是整体的实现代码：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">class Trie&#123;\npublic:\n    Trie() : children(26), isEnd(false)&#123;&#125;;\n    \n    void insert(std::string word)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : word)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                node-&gt;children[ch] &#x3D;&#x3D; new Trie();\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        node-&gt;isEnd &#x3D; false;\n    &#125;\n    \n    bool search(std::string word)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(word);\n        return node !&#x3D; nullptr &amp;&amp; node-&gt;isEnd;\n    &#125;\n    \n    bool startWith(std::string prefix)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(prefix) !&#x3D; nullptr;\n    &#125;\n    \nprivate:\n    std::vecotr&lt;Trie *&gt; children;\n    bool isEnd;\n    \n    Trie *searchPrefix(std::string prefix)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : prefix)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                return nullptr;\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        return node;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"线段树（Segment-Tree）\"><a href=\"#线段树（Segment-Tree）\" class=\"headerlink\" title=\"线段树（Segment Tree）\"></a>线段树（Segment Tree）</h2>","feature":true,"text":"树形结构##前缀树（Trie） 前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。 前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">树形结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88Segment-Tree%EF%BC%89\"><span class=\"toc-text\">线段树（Segment Tree）</span></a></li></ol></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"进程间的通信和调度","date":"2022-04-17T12:26:03.898Z","updated":"2022-04-17T14:08:06.511Z","comments":true,"path":"api/articles/进程间的通信和调度.json","keywords":null,"cover":null,"text":"#进程间的通信和调度 进程间通信进程其实就是计算机对于正在运行程序的一个抽象。对于进程而言，不同的进程之间需要进行信息传递，也就是我们说的通信。可是该怎么通信呢？一个进程如何把信息传递给另一个？如何确保两个及以上的进程在关键活动中不会出现交叉？或者进程之间有顺序，我们该如何保证这...","link":"","photos":[],"count_time":{"symbolsCount":573,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}