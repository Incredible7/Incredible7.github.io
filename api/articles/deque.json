{"title":"Deque","uid":"308638f730680abc5f45d9c3a761dd7f","slug":"Deque","date":"2022-05-07T03:35:50.000Z","updated":"2022-05-07T03:37:54.834Z","comments":true,"path":"api/articles/Deque.json","keywords":null,"cover":null,"content":"<h1 id=\"C-deque解析\"><a href=\"#C-deque解析\" class=\"headerlink\" title=\"C++ deque解析\"></a>C++ deque解析</h1><p>双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。</p>\n<p>与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操作例如增添和删除提供了遍历，因为不需要进行“移动，配置，释放”等一系列操作，但这样的代价就是deque拥有复杂的数据结构。</p>\n<p>deque使用map（并非STL库里的map）这种结构作为主控，每个map实际上是一个指向另一块被称为缓冲区的连续内存的指针，而这些缓冲区才是deque的实际存储结构，如果初始化时没有指定缓冲区大小则默认为512bytes。deque利用map串联起来的关系网形成对用户透明的连续存储空间，串联任务由迭代器完成。</p>\n<p>deque迭代器结构设计：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; 迭代器所含成员数据\n  value_pointer cur;    &#x2F;&#x2F; 指向所在缓冲区的当前元素\n  value_pointer first;  &#x2F;&#x2F; 指向所在缓冲区的头部\n  value_pointer last;   &#x2F;&#x2F; 指向所在缓冲区的尾部\n  map_pointer   node;   &#x2F;&#x2F; 缓冲区所在节点</code></pre>\n\n<p>deque和list可以作为底层容器实现stack和queue。</p>\n","feature":true,"text":"C++ deque解析双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。 与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操...","link":"","photos":[],"count_time":{"symbolsCount":621,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C-deque%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">C++ deque解析</span></a></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TREE","uid":"43d8f1daf2b5d80192eb6bd522c6ba38","slug":"TREE","date":"2022-05-07T03:36:26.000Z","updated":"2022-05-07T03:38:17.068Z","comments":true,"path":"api/articles/TREE.json","keywords":null,"cover":null,"text":"树形结构##前缀树（Trie） 前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。 前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"auto","uid":"511a0eaa98d66dcd924e31e900b34f97","slug":"auto","date":"2022-05-07T03:35:16.000Z","updated":"2022-05-07T03:35:34.587Z","comments":true,"path":"api/articles/auto.json","keywords":null,"cover":null,"text":"auto怎样实现类型推断auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。 auto的推导规则：（1）当不声明为指针或是引用时，auto的推导结果和初始...","link":"","photos":[],"count_time":{"symbolsCount":669,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}