{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"auto","date":"2022-04-15T03:45:27.743Z","updated":"2022-05-05T13:02:51.515Z","comments":true,"path":"api/articles/auto.json","keywords":null,"cover":null,"content":"<h1 id=\"auto怎样实现类型推断\"><a href=\"#auto怎样实现类型推断\" class=\"headerlink\" title=\"auto怎样实现类型推断\"></a>auto怎样实现类型推断</h1><p>auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。</p>\n<p>auto的推导规则：<br>（1）当不声明为指针或是引用时，auto的推导结果和初始化表达式抛弃引用和const属性限定符后的类型一致。<br>（2）当声明为指针或是引用时，auto的推导结果将保持初始化表达式的const属性。</p>\n<p>auto的限制：</p>\n<p>（1）auto不可以用于函数参数</p>\n<p>（2）auto不可以用于非静态成员变量。<strong>auto仅能够用于推导static const的整型或者枚举成员</strong>（因为其他静态成员无法在类或是结构体中就地完成初始化，都需要在类的外部进行初始化）。C++11中支持非静态成员变量的就地初始化，但却不支持auto类型的非静态成员变量初始化。</p>\n<p>（3）auto类型不能用于定义数组。</p>\n<p>（4）auto类型无法导出模板参数。</p>\n<p>auto使用的是<strong>模板实参推断</strong>*（Template Argument Deduction）的机制。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。</p>\n<p>decltype比auto更确切地推断名称或表达式的类型<em>（即原始的</em>declared type），实现原理应该和auto类似，只是特殊情况不太一样，具体实现需要更多考虑。</p>\n<p>C++14中开始支持用decltype(auto)推断原始类型。</p>\n","text":"auto怎样实现类型推断auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。 auto的推导规则：（1）当不声明为指针或是引用时，auto的推导结果和初始...","link":"","photos":[],"count_time":{"symbolsCount":669,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#auto%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD\"><span class=\"toc-text\">auto怎样实现类型推断</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"deque","date":"2022-04-15T03:57:07.603Z","updated":"2022-04-15T04:50:13.024Z","comments":true,"path":"api/articles/deque.json","keywords":null,"cover":null,"text":"C++ deque解析双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。 与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操...","link":"","photos":[],"count_time":{"symbolsCount":621,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}