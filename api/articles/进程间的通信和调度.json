{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"进程间的通信和调度","date":"2022-04-17T12:26:03.898Z","updated":"2022-04-17T14:08:06.511Z","comments":true,"path":"api/articles/进程间的通信和调度.json","keywords":null,"cover":null,"content":"<p>#进程间的通信和调度</p>\n<h2 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h2><p>进程其实就是计算机对于正在运行程序的一个抽象。对于进程而言，不同的进程之间需要进行信息传递，也就是我们说的通信。可是该怎么通信呢？一个进程如何把信息传递给另一个？如何确保两个及以上的进程在关键活动中不会出现交叉？或者进程之间有顺序，我们该如何保证这种通信的顺序？</p>\n<p>首先我们要清楚，进程的运行是受限的，因为不同进程的并发或者并行操作会使得一些固有的认知遭到冲击——他们会改变彼此的信息。这是因为进程的成功运行依赖于精确的时序逻辑，这个时序被称为竞争条件（race condition）。为了避免竞争条件，或者说让进程有序地执行，我们就不能让进程在访问共享内容时随心所欲，也就是说，我们需要让一种互斥（mutual exclusion）来使得一个进程工作时，其他进程不得进行同样的操作。</p>\n<p>我们把对共享内存进行访问的程序片断称为临界区域（critical region）或者临界区（critical section）。同一时间，我们只希望一个进程在临界区内更新共享内存，而其他进程必须等待，直到临界区不再被任意进程占有。</p>\n<p>接下来我们尝试完成这项操作。</p>\n<ol>\n<li><p>屏蔽中断：</p>\n<p> 单处理器系统对于这种情况的处理估计是最简单的，在进程进入临界区后立即屏蔽所有中断，处理完毕。然而正如你所见，现在完全不好使了，下一个。</p>\n</li>\n<li><p>锁变量：</p>\n</li>\n</ol>\n","feature":true,"text":"#进程间的通信和调度 进程间通信进程其实就是计算机对于正在运行程序的一个抽象。对于进程而言，不同的进程之间需要进行信息传递，也就是我们说的通信。可是该怎么通信呢？一个进程如何把信息传递给另一个？如何确保两个及以上的进程在关键活动中不会出现交叉？或者进程之间有顺序，我们该如何保证这...","link":"","photos":[],"count_time":{"symbolsCount":573,"symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程间通信</span></a></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"树","date":"2022-05-05T12:54:38.145Z","updated":"2022-05-06T14:31:43.994Z","comments":true,"path":"api/articles/树.json","keywords":null,"cover":null,"text":"树形结构##前缀树（Trie） 前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。 前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"KMP","date":"2022-04-15T16:37:36.087Z","updated":"2022-04-16T08:00:49.472Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":null,"text":"KMP算法详解如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？ 那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}