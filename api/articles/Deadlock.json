{"title":"Deadlock","uid":"e9d66126d8468f474b743a038bfbe91d","slug":"Deadlock","date":"2022-06-04T13:41:56.000Z","updated":"2022-06-05T08:27:11.972Z","comments":true,"path":"api/articles/Deadlock.json","keywords":null,"cover":[],"content":"<h1 id=\"死锁简介\"><a href=\"#死锁简介\" class=\"headerlink\" title=\"死锁简介\"></a>死锁简介</h1><p>如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。由于资源不可被抢占的因素导致的死锁被称为资源死锁，这是最常见的类型。</p>\n<p>资源死锁的条件有以下四个，且必须同时满足：</p>\n<ol>\n<li>互斥条件</li>\n<li>占有和等待条件</li>\n<li>不可抢占条件，资源只能被占有它的进程显式地释放</li>\n<li>环路等待条件，这里指进程组成的环路</li>\n</ol>\n<p>根据死锁的触发条件，可以考虑四种处理死锁的策略：</p>\n<ol>\n<li>忽略该问题。如果你忽略它，它没准也会忽略你——哦当然，也许。</li>\n<li>检测锁并恢复。让死锁发生，检测他们是否发生，一旦发生死锁，采取行动解决问题。</li>\n<li>仔细对资源进行分配，动态地避免死锁。</li>\n<li>破坏引起死锁的四个必要条件之一，防止其发生。</li>\n</ol>\n<p>接下来我们对这些问题一一进行讨论。</p>\n<p>第一条自不必说，不管怎样，掩耳盗铃总是一个糟糕的选择，而且倒霉的总是自己。</p>\n<p>第二条技术是死锁检测和恢复，系统并不能阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后采取恢复措施。</p>\n<p>检测算法很简单， 进程和资源可以视为一个图的各个结点，并且任意进程完成后都能释放资源，我们要做的就是检测这个图是否有环，这就是单纯的深度遍历，若有环，那么就会发生死锁。</p>\n<p>上面这个是单一资源的情况，若有多种资源，我们需要构建一个矩阵来描述资源：</p>\n<p><img src=\"D:\\Blog\\source\\about\\image-20220604220457204.png\" alt=\"image-20220604220457204\"></p>\n<p>死锁检测算法就是基于向量的比较。总体资源是恒定的，请求资源不得超出这一限制；一开始每个进程都是没有标记过的，算法开始会对进程做标记，进程被标记后就表明他们能够被执行，不会进入死锁，算法结束后没有被标记的进程都是处于死锁状态的进程，该算法假定了一个最坏情形，所有的进程在退出以前都会不停地获取资源。死锁检测算法如下：</p>\n<ol>\n<li>寻找一个没有标记的进程$P_i$，对它而言R矩阵的第 i 行向量小于或等于A。</li>\n<li>如果找到了这样一个进程，将C矩阵的第 i 行向量加到A中，标记该进程， 转到第1步。</li>\n<li>没有这样的进程，算法结束。</li>\n</ol>\n<p>如何从死锁中恢复呢？</p>\n<ol>\n<li>利用抢占恢复。需要进行人工干预，主要取决于资源的特性，比如哪个资源好回收。</li>\n<li>利用回滚恢复。周期性地对进程进行检查点检查，就是将进程的状态写入一个文件以备以后重启，不仅包括了存储映像，还包括资源状态。一旦检测到死锁， 很容易发现需要哪些资源。回复到一个较早的资源点之后，把这个引发死锁的资源分配给这个进程。</li>\n<li>通过杀死进程恢复。不用解释，杀死互相争夺资源的进程的其中一方，其他进程可以继续。当然，尽量杀死不会带来副作用的进程。</li>\n</ol>\n<p>如何避免死锁呢？</p>\n<p>首先了解什么是安全状态和不安全状态。如果没有死锁发生，并且即使所有的进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，我们就称该状态是安全的。反之就是不安全的。值得注意的是，不安全状态并不是死锁。实际上，甚至有进程能够完成。</p>\n<p>这里可以使用银行家算法来检测是否处于不安全状态。</p>\n<p>死锁的预防</p>\n<ol>\n<li><p>破坏互斥条件：如果资源不被一个进程所独占，那么死锁肯定不会产生。允许两个进程同时使用资源肯定会造成混乱，我们可以使用假脱机技术解决问题。当然，一开始就可以避免分配那些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源。</p>\n</li>\n<li><p>破坏占有并等待条件：只要禁止已持有资源的进程再等待其他资源便可以消除死锁。一种实现方法是规定所有进程在开始执行期前请求所需的全部资源。如果所需的全部资源可用， 那么就将它们分配给这个进程，于是该进程肯定能结束；如果有一个或多个资源正被使用，那么就不进行分配，进程等待。\t另一种破坏占有并等待条件的略有不同的方案是，要求等一个进程请求资源时，先暂时是放弃当前占用的所有资源，然后再尝试一次获得所需的全部资源。</p>\n</li>\n<li><p>破坏不可抢占条件：</p>\n</li>\n<li><p>破坏环路等待条件：消除环路有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，他必须先释放第一个资源。但假若进程正在把一个大文件从磁带机上读入并送到打印机打印，那么这种限制是不可接受的。    另一种方法是将所有的资源统一编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序提出，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。</p>\n</li>\n</ol>\n","feature":true,"text":"死锁简介如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。由于资源不可被抢占的因素导致的死锁被称为资源死锁，这是最常见的类型。 资源死锁的条件有以下四个，且必须同时满足： 互斥条件 占有和等待条件 不可抢占条件，资源只能被占...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Operator System","slug":"Operator-System","count":1,"path":"api/tags/Operator-System.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">死锁简介</span></a></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"TREE","uid":"43d8f1daf2b5d80192eb6bd522c6ba38","slug":"TREE","date":"2022-05-07T03:36:26.000Z","updated":"2022-05-26T14:17:08.243Z","comments":true,"path":"api/articles/TREE.json","keywords":null,"cover":null,"text":"树形结构前缀树（Trie）前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。 前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针对于其...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}