{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"KMP","date":"2022-04-15T16:37:36.087Z","updated":"2022-04-16T08:00:49.472Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":null,"content":"<h1 id=\"KMP算法详解\"><a href=\"#KMP算法详解\" class=\"headerlink\" title=\"KMP算法详解\"></a>KMP算法详解</h1><p>如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？</p>\n<p>那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则重复，失败则删除下标并后移一位（比较指针回溯），重复匹配过程。</p>\n<p>这种方式不是不可以哈，但是时间复杂度直接达到$O(n^2)$，多少有点离谱了。那我们能不能想一种办法来节约时间消耗呢？我们想一想可以优化的点在哪里。</p>\n<p>我们可以从上述的思路中看出来，其实核心的思想就是前缀的匹配。那么优化的点也就在这里，如果我们能够将匹配成功的前缀下标标注，那么就不用一个一个去浪费时间匹配了，而是有目的地找的匹配目标从而大大减少时间资源的浪费。那么，怎么做到这一点呢？</p>\n<p>再去考虑最简单的暴力算法，当比较指针回溯的时候，我们发现，子串与母串匹配失败的时候，下标之前的部分其实是相同的，那么我们是否可以找到这部分的共通性，从而加速这给匹配的过程呢？答案是有的，如果我们能够找到前面相同的这部分的重复点，也就是公共前后缀，我们在指针回溯的时候就可以直接回溯到后缀的下标然后开始匹配，那么时间将会大幅度缩小。</p>\n<p>思路明确，那么我们用一个next数组用来标注每个下标之前公共后缀的起始下标，这样，当我们子串匹配失败时，就可以通过next检索指针回溯的下标，从而达到算法的目的，这就是著名的KMP算法。</p>\n<p>代码如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; KMP算法\nvoid getNext(string t, vector&lt;int&gt; &amp;next) &#123;\n    int i &#x3D; 0, j &#x3D; -1;\n    next.resize(t.size());\n    next[0] &#x3D; -1;\n    while (i &lt; t.size() - 1) &#123;\n        if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; t[j]) &#123;\n            next[++i] &#x3D; ++j;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n    &#125;\n&#125;\n\nint KMP_Match(string s, string t, int pos) &#123;    &#x2F;&#x2F;s母串，t子串\n    int i &#x3D; pos, j &#x3D; 0;\n    vector&lt;int&gt; next;\n    getNext(t, next);\n    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n        if (s[i] &#x3D;&#x3D; t[j]) &#123;\n            i++; \n            j++;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n        if (j &#x3D;&#x3D; -1) &#123;\n            j++;\n            i++;\n        &#125;\n    &#125;\n    return j &gt;&#x3D; t.size() ? i - t.size() : -1;\n&#125;</code></pre>\n","feature":true,"text":"KMP算法详解如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？ 那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">KMP算法详解</span></a></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"进程间的通信和调度","date":"2022-04-17T12:26:03.898Z","updated":"2022-04-17T14:08:06.511Z","comments":true,"path":"api/articles/进程间的通信和调度.json","keywords":null,"cover":null,"text":"#进程间的通信和调度 进程间通信进程其实就是计算机对于正在运行程序的一个抽象。对于进程而言，不同的进程之间需要进行信息传递，也就是我们说的通信。可是该怎么通信呢？一个进程如何把信息传递给另一个？如何确保两个及以上的进程在关键活动中不会出现交叉？或者进程之间有顺序，我们该如何保证这...","link":"","photos":[],"count_time":{"symbolsCount":573,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"deque","date":"2022-04-15T03:57:07.603Z","updated":"2022-04-15T04:50:13.024Z","comments":true,"path":"api/articles/deque.json","keywords":null,"cover":null,"text":"C++ deque解析双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。 与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操...","link":"","photos":[],"count_time":{"symbolsCount":621,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}