{"title":"KMP","uid":"53896b079468d4c41963b2300dea196e","slug":"KMP","date":"2022-05-07T03:33:21.000Z","updated":"2022-05-07T03:38:03.231Z","comments":true,"path":"api/articles/KMP.json","keywords":null,"cover":null,"content":"<h1 id=\"KMP算法详解\"><a href=\"#KMP算法详解\" class=\"headerlink\" title=\"KMP算法详解\"></a>KMP算法详解</h1><p>如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？</p>\n<p>那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则重复，失败则删除下标并后移一位（比较指针回溯），重复匹配过程。</p>\n<p>这种方式不是不可以哈，但是时间复杂度直接达到$O(n^2)$，多少有点离谱了。那我们能不能想一种办法来节约时间消耗呢？我们想一想可以优化的点在哪里。</p>\n<p>我们可以从上述的思路中看出来，其实核心的思想就是前缀的匹配。那么优化的点也就在这里，如果我们能够将匹配成功的前缀下标标注，那么就不用一个一个去浪费时间匹配了，而是有目的地找的匹配目标从而大大减少时间资源的浪费。那么，怎么做到这一点呢？</p>\n<p>再去考虑最简单的暴力算法，当比较指针回溯的时候，我们发现，子串与母串匹配失败的时候，下标之前的部分其实是相同的，那么我们是否可以找到这部分的共通性，从而加速这给匹配的过程呢？答案是有的，如果我们能够找到前面相同的这部分的重复点，也就是公共前后缀，我们在指针回溯的时候就可以直接回溯到后缀的下标然后开始匹配，那么时间将会大幅度缩小。</p>\n<p>思路明确，那么我们用一个next数组用来标注每个下标之前公共后缀的起始下标，这样，当我们子串匹配失败时，就可以通过next检索指针回溯的下标，从而达到算法的目的，这就是著名的KMP算法。</p>\n<p>代码如下：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">&#x2F;&#x2F; KMP算法\nvoid getNext(string t, vector&lt;int&gt; &amp;next) &#123;\n    int i &#x3D; 0, j &#x3D; -1;\n    next.resize(t.size());\n    next[0] &#x3D; -1;\n    while (i &lt; t.size() - 1) &#123;\n        if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; t[j]) &#123;\n            next[++i] &#x3D; ++j;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n    &#125;\n&#125;\n\nint KMP_Match(string s, string t, int pos) &#123;    &#x2F;&#x2F;s母串，t子串\n    int i &#x3D; pos, j &#x3D; 0;\n    vector&lt;int&gt; next;\n    getNext(t, next);\n    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n        if (s[i] &#x3D;&#x3D; t[j]) &#123;\n            i++; \n            j++;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n        if (j &#x3D;&#x3D; -1) &#123;\n            j++;\n            i++;\n        &#125;\n    &#125;\n    return j &gt;&#x3D; t.size() ? i - t.size() : -1;\n&#125;</code></pre>\n","text":"KMP算法详解如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？ 那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","count":1,"path":"api/tags/Algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#KMP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">KMP算法详解</span></a></li></ol>","author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"auto","uid":"511a0eaa98d66dcd924e31e900b34f97","slug":"auto","date":"2022-05-07T03:35:16.000Z","updated":"2022-05-07T03:35:34.587Z","comments":true,"path":"api/articles/auto.json","keywords":null,"cover":null,"text":"auto怎样实现类型推断auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。 auto的推导规则：（1）当不声明为指针或是引用时，auto的推导结果和初始...","link":"","photos":[],"count_time":{"symbolsCount":669,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"Incredible7","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"This is my little blog","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}