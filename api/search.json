[{"id":"e9d66126d8468f474b743a038bfbe91d","title":"Deadlock","content":"死锁简介如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁的。由于资源不可被抢占的因素导致的死锁被称为资源死锁，这是最常见的类型。\n资源死锁的条件有以下四个，且必须同时满足：\n\n互斥条件\n占有和等待条件\n不可抢占条件，资源只能被占有它的进程显式地释放\n环路等待条件，这里指进程组成的环路\n\n根据死锁的触发条件，可以考虑四种处理死锁的策略：\n\n忽略该问题。如果你忽略它，它没准也会忽略你——哦当然，也许。\n检测锁并恢复。让死锁发生，检测他们是否发生，一旦发生死锁，采取行动解决问题。\n仔细对资源进行分配，动态地避免死锁。\n破坏引起死锁的四个必要条件之一，防止其发生。\n\n接下来我们对这些问题一一进行讨论。\n第一条自不必说，不管怎样，掩耳盗铃总是一个糟糕的选择，而且倒霉的总是自己。\n第二条技术是死锁检测和恢复，系统并不能阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后采取恢复措施。\n检测算法很简单， 进程和资源可以视为一个图的各个结点，并且任意进程完成后都能释放资源，我们要做的就是检测这个图是否有环，这就是单纯的深度遍历，若有环，那么就会发生死锁。\n上面这个是单一资源的情况，若有多种资源，我们需要构建一个矩阵来描述资源：\n\n死锁检测算法就是基于向量的比较。总体资源是恒定的，请求资源不得超出这一限制；一开始每个进程都是没有标记过的，算法开始会对进程做标记，进程被标记后就表明他们能够被执行，不会进入死锁，算法结束后没有被标记的进程都是处于死锁状态的进程，该算法假定了一个最坏情形，所有的进程在退出以前都会不停地获取资源。死锁检测算法如下：\n\n寻找一个没有标记的进程$P_i$，对它而言R矩阵的第 i 行向量小于或等于A。\n如果找到了这样一个进程，将C矩阵的第 i 行向量加到A中，标记该进程， 转到第1步。\n没有这样的进程，算法结束。\n\n如何从死锁中恢复呢？\n\n利用抢占恢复。需要进行人工干预，主要取决于资源的特性，比如哪个资源好回收。\n利用回滚恢复。周期性地对进程进行检查点检查，就是将进程的状态写入一个文件以备以后重启，不仅包括了存储映像，还包括资源状态。一旦检测到死锁， 很容易发现需要哪些资源。回复到一个较早的资源点之后，把这个引发死锁的资源分配给这个进程。\n通过杀死进程恢复。不用解释，杀死互相争夺资源的进程的其中一方，其他进程可以继续。当然，尽量杀死不会带来副作用的进程。\n\n如何避免死锁呢？\n首先了解什么是安全状态和不安全状态。如果没有死锁发生，并且即使所有的进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，我们就称该状态是安全的。反之就是不安全的。值得注意的是，不安全状态并不是死锁。实际上，甚至有进程能够完成。\n这里可以使用银行家算法来检测是否处于不安全状态。\n死锁的预防\n\n破坏互斥条件：如果资源不被一个进程所独占，那么死锁肯定不会产生。允许两个进程同时使用资源肯定会造成混乱，我们可以使用假脱机技术解决问题。当然，一开始就可以避免分配那些不是绝对必需的资源，尽量做到尽可能少的进程可以真正请求资源。\n\n破坏占有并等待条件：只要禁止已持有资源的进程再等待其他资源便可以消除死锁。一种实现方法是规定所有进程在开始执行期前请求所需的全部资源。如果所需的全部资源可用， 那么就将它们分配给这个进程，于是该进程肯定能结束；如果有一个或多个资源正被使用，那么就不进行分配，进程等待。\t另一种破坏占有并等待条件的略有不同的方案是，要求等一个进程请求资源时，先暂时是放弃当前占用的所有资源，然后再尝试一次获得所需的全部资源。\n\n破坏不可抢占条件：\n\n破坏环路等待条件：消除环路有几种方法。一种是保证每一个进程在任何时刻只能占用一个资源，如果要请求另外一个资源，他必须先释放第一个资源。但假若进程正在把一个大文件从磁带机上读入并送到打印机打印，那么这种限制是不可接受的。    另一种方法是将所有的资源统一编号，进程可以在任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序提出，进程可以先请求打印机后请求磁带机，但不可以先请求绘图仪后请求打印机。\n\n\n","slug":"Deadlock","date":"2022-06-04T13:41:56.000Z","categories_index":"","tags_index":"Operator System","author_index":"Incredible7"},{"id":"43d8f1daf2b5d80192eb6bd522c6ba38","title":"TREE","content":"树形结构前缀树（Trie）前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。\n前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针对于其他的例如平衡树或哈希表这种同样可以做到搜索字符串数据集中的单词的数据结构，Trie树可以做到：\n\n找到具有同一前缀的全部键值\n按字典序枚举字符串的数据集\n\n前缀树可以利用vector或者map存储结点内容，区别在于vector可能会浪费空间，但是执行较快；map内存管理灵活，但是速度略慢。\n节点的内容信息可以包括你所需要的字符串元素，一般来说是26个英文字母，当然你可以自行增添。为了确定该单词是否已经结束输入，我们增加一个isEnd的布尔类型变量来标识。\n以下是整体的实现代码：\nclass Trie&#123;\npublic:\n    Trie() : children(26), isEnd(false)&#123;&#125;;\n    \n    void insert(std::string word)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : word)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                node-&gt;children[ch] &#x3D;&#x3D; new Trie();\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        node-&gt;isEnd &#x3D; false;\n    &#125;\n    \n    bool search(std::string word)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(word);\n        return node !&#x3D; nullptr &amp;&amp; node-&gt;isEnd;\n    &#125;\n    \n    bool startWith(std::string prefix)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(prefix) !&#x3D; nullptr;\n    &#125;\n    \nprivate:\n    std::vecotr&lt;Trie *&gt; children;\n    bool isEnd;\n    \n    Trie *searchPrefix(std::string prefix)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : prefix)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                return nullptr;\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        return node;\n    &#125;\n&#125;;\n\n线段树（Segment Tree）","slug":"TREE","date":"2022-05-07T03:36:26.000Z","categories_index":"","tags_index":"DataStructure","author_index":"Incredible7"},{"id":"308638f730680abc5f45d9c3a761dd7f","title":"Deque","content":"C++ deque解析双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。\n与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操作例如增添和删除提供了遍历，因为不需要进行“移动，配置，释放”等一系列操作，但这样的代价就是deque拥有复杂的数据结构。\ndeque使用map（并非STL库里的map）这种结构作为主控，每个map实际上是一个指向另一块被称为缓冲区的连续内存的指针，而这些缓冲区才是deque的实际存储结构，如果初始化时没有指定缓冲区大小则默认为512bytes。deque利用map串联起来的关系网形成对用户透明的连续存储空间，串联任务由迭代器完成。\ndeque迭代器结构设计：\n&#x2F;&#x2F; 迭代器所含成员数据\n  value_pointer cur;    &#x2F;&#x2F; 指向所在缓冲区的当前元素\n  value_pointer first;  &#x2F;&#x2F; 指向所在缓冲区的头部\n  value_pointer last;   &#x2F;&#x2F; 指向所在缓冲区的尾部\n  map_pointer   node;   &#x2F;&#x2F; 缓冲区所在节点\n\ndeque和list可以作为底层容器实现stack和queue。\n","slug":"Deque","date":"2022-05-07T03:35:50.000Z","categories_index":"","tags_index":"DataStructure","author_index":"Incredible7"},{"id":"511a0eaa98d66dcd924e31e900b34f97","title":"auto","content":"auto怎样实现类型推断auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。\nauto的推导规则：（1）当不声明为指针或是引用时，auto的推导结果和初始化表达式抛弃引用和const属性限定符后的类型一致。（2）当声明为指针或是引用时，auto的推导结果将保持初始化表达式的const属性。\nauto的限制：\n（1）auto不可以用于函数参数\n（2）auto不可以用于非静态成员变量。auto仅能够用于推导static const的整型或者枚举成员（因为其他静态成员无法在类或是结构体中就地完成初始化，都需要在类的外部进行初始化）。C++11中支持非静态成员变量的就地初始化，但却不支持auto类型的非静态成员变量初始化。\n（3）auto类型不能用于定义数组。\n（4）auto类型无法导出模板参数。\nauto使用的是模板实参推断（Template Argument Deduction）的机制。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。\ndecltype比auto更确切地推断名称或表达式的类型（即原始的declared type），实现原理应该和auto类似，只是特殊情况不太一样，具体实现需要更多考虑。\nC++14中开始支持用decltype(auto)推断原始类型。\n","slug":"auto","date":"2022-05-07T03:35:16.000Z","categories_index":"","tags_index":"C++","author_index":"Incredible7"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP算法详解如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？\n那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则重复，失败则删除下标并后移一位（比较指针回溯），重复匹配过程。\n这种方式不是不可以哈，但是时间复杂度直接达到$O(n^2)$，多少有点离谱了。那我们能不能想一种办法来节约时间消耗呢？我们想一想可以优化的点在哪里。\n我们可以从上述的思路中看出来，其实核心的思想就是前缀的匹配。那么优化的点也就在这里，如果我们能够将匹配成功的前缀下标标注，那么就不用一个一个去浪费时间匹配了，而是有目的地找的匹配目标从而大大减少时间资源的浪费。那么，怎么做到这一点呢？\n再去考虑最简单的暴力算法，当比较指针回溯的时候，我们发现，子串与母串匹配失败的时候，下标之前的部分其实是相同的，那么我们是否可以找到这部分的共通性，从而加速这给匹配的过程呢？答案是有的，如果我们能够找到前面相同的这部分的重复点，也就是公共前后缀，我们在指针回溯的时候就可以直接回溯到后缀的下标然后开始匹配，那么时间将会大幅度缩小。\n思路明确，那么我们用一个next数组用来标注每个下标之前公共后缀的起始下标，这样，当我们子串匹配失败时，就可以通过next检索指针回溯的下标，从而达到算法的目的，这就是著名的KMP算法。\n代码如下：\n&#x2F;&#x2F; KMP算法\nvoid getNext(string t, vector&lt;int&gt; &amp;next) &#123;\n    int i &#x3D; 0, j &#x3D; -1;\n    next.resize(t.size());\n    next[0] &#x3D; -1;\n    while (i &lt; t.size() - 1) &#123;\n        if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; t[j]) &#123;\n            next[++i] &#x3D; ++j;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n    &#125;\n&#125;\n\nint KMP_Match(string s, string t, int pos) &#123;    &#x2F;&#x2F;s母串，t子串\n    int i &#x3D; pos, j &#x3D; 0;\n    vector&lt;int&gt; next;\n    getNext(t, next);\n    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n        if (s[i] &#x3D;&#x3D; t[j]) &#123;\n            i++; \n            j++;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n        if (j &#x3D;&#x3D; -1) &#123;\n            j++;\n            i++;\n        &#125;\n    &#125;\n    return j &gt;&#x3D; t.size() ? i - t.size() : -1;\n&#125;\n","slug":"KMP","date":"2022-05-07T03:33:21.000Z","categories_index":"","tags_index":"Algorithm","author_index":"Incredible7"}]