[{"id":"43d8f1daf2b5d80192eb6bd522c6ba38","title":"TREE","content":"树形结构##前缀树（Trie）\n前缀树的应用很多，例如搜索算法里的关键词推荐、拼写检查、IP路由匹配、打字检测等。\n前缀树实际就是N叉树的一种特殊形式，通常我们用前缀树来存储字符串，因为所有结点的后代都与该节点相对应的字符串有着共同前缀，因此很容易搜索以特定前缀开头的任何单词。针对于其他的例如平衡树或哈希表这种同样可以做到搜索字符串数据集中的单词的数据结构，Trie树可以做到：\n\n找到具有同一前缀的全部键值\n按字典序枚举字符串的数据集\n\n前缀树可以利用vector或者map存储结点内容，区别在于vector可能会浪费空间，但是执行较快；map内存管理灵活，但是速度略慢。\n节点的内容信息可以包括你所需要的字符串元素，一般来说是26个英文字母，当然你可以自行增添。为了确定该单词是否已经结束输入，我们增加一个isEnd的布尔类型变量来标识。\n以下是整体的实现代码：\nclass Trie&#123;\npublic:\n    Trie() : children(26), isEnd(false)&#123;&#125;;\n    \n    void insert(std::string word)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : word)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                node-&gt;children[ch] &#x3D;&#x3D; new Trie();\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        node-&gt;isEnd &#x3D; false;\n    &#125;\n    \n    bool search(std::string word)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(word);\n        return node !&#x3D; nullptr &amp;&amp; node-&gt;isEnd;\n    &#125;\n    \n    bool startWith(std::string prefix)&#123;\n        Trie *node &#x3D; this-&gt;searchPrefix(prefix) !&#x3D; nullptr;\n    &#125;\n    \nprivate:\n    std::vecotr&lt;Trie *&gt; children;\n    bool isEnd;\n    \n    Trie *searchPrefix(std::string prefix)&#123;\n        Trie *node &#x3D; this;\n        for(char ch : prefix)&#123;\n            ch -&#x3D; &#39;a&#39;;\n            if(node-&gt;children[ch] &#x3D;&#x3D; nullptr)\n                return nullptr;\n            node &#x3D; node-&gt;children[ch];\n        &#125;\n        return node;\n    &#125;\n&#125;;\n\n线段树（Segment Tree）","slug":"TREE","date":"2022-05-07T03:36:26.000Z","categories_index":"","tags_index":"","author_index":"Incredible7"},{"id":"308638f730680abc5f45d9c3a761dd7f","title":"Deque","content":"C++ deque解析双端队列deque(double-ended queue)，容量可动态变化，两段可插入删除，是顺序容器。deque实际分配内存比当前容纳元素内存要多，空闲空间在增加元素时使用。\n与vector不同，deque的底层存储空间并不是连续的。离散的存储空间给数据操作例如增添和删除提供了遍历，因为不需要进行“移动，配置，释放”等一系列操作，但这样的代价就是deque拥有复杂的数据结构。\ndeque使用map（并非STL库里的map）这种结构作为主控，每个map实际上是一个指向另一块被称为缓冲区的连续内存的指针，而这些缓冲区才是deque的实际存储结构，如果初始化时没有指定缓冲区大小则默认为512bytes。deque利用map串联起来的关系网形成对用户透明的连续存储空间，串联任务由迭代器完成。\ndeque迭代器结构设计：\n&#x2F;&#x2F; 迭代器所含成员数据\n  value_pointer cur;    &#x2F;&#x2F; 指向所在缓冲区的当前元素\n  value_pointer first;  &#x2F;&#x2F; 指向所在缓冲区的头部\n  value_pointer last;   &#x2F;&#x2F; 指向所在缓冲区的尾部\n  map_pointer   node;   &#x2F;&#x2F; 缓冲区所在节点\n\ndeque和list可以作为底层容器实现stack和queue。\n","slug":"Deque","date":"2022-05-07T03:35:50.000Z","categories_index":"","tags_index":"","author_index":"Incredible7"},{"id":"511a0eaa98d66dcd924e31e900b34f97","title":"auto","content":"auto怎样实现类型推断auto并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用auto声明的变量必须马上初始化，以让编译器推断出它的类型，并且在编译时将auto占位符替换为真正的类型。\nauto的推导规则：（1）当不声明为指针或是引用时，auto的推导结果和初始化表达式抛弃引用和const属性限定符后的类型一致。（2）当声明为指针或是引用时，auto的推导结果将保持初始化表达式的const属性。\nauto的限制：\n（1）auto不可以用于函数参数\n（2）auto不可以用于非静态成员变量。auto仅能够用于推导static const的整型或者枚举成员（因为其他静态成员无法在类或是结构体中就地完成初始化，都需要在类的外部进行初始化）。C++11中支持非静态成员变量的就地初始化，但却不支持auto类型的非静态成员变量初始化。\n（3）auto类型不能用于定义数组。\n（4）auto类型无法导出模板参数。\nauto使用的是模板实参推断*（Template Argument Deduction）的机制。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。\ndecltype比auto更确切地推断名称或表达式的类型（即原始的declared type），实现原理应该和auto类似，只是特殊情况不太一样，具体实现需要更多考虑。\nC++14中开始支持用decltype(auto)推断原始类型。\n","slug":"auto","date":"2022-05-07T03:35:16.000Z","categories_index":"","tags_index":"C++","author_index":"Incredible7"},{"id":"53896b079468d4c41963b2300dea196e","title":"KMP","content":"KMP算法详解如果要两个字符串相互匹配，以判断其中一个是否是另一个的子串，并且返回匹配下标，怎么办？\n那么第一时间想出来的办法肯定是遍历字符串。我们称需要匹配的为s1，被匹配的是s2（也就是说判断s1是否是s2的子串）。然后找到匹配的第一个下标，再从这个下标出开始继续匹配，成功则重复，失败则删除下标并后移一位（比较指针回溯），重复匹配过程。\n这种方式不是不可以哈，但是时间复杂度直接达到$O(n^2)$，多少有点离谱了。那我们能不能想一种办法来节约时间消耗呢？我们想一想可以优化的点在哪里。\n我们可以从上述的思路中看出来，其实核心的思想就是前缀的匹配。那么优化的点也就在这里，如果我们能够将匹配成功的前缀下标标注，那么就不用一个一个去浪费时间匹配了，而是有目的地找的匹配目标从而大大减少时间资源的浪费。那么，怎么做到这一点呢？\n再去考虑最简单的暴力算法，当比较指针回溯的时候，我们发现，子串与母串匹配失败的时候，下标之前的部分其实是相同的，那么我们是否可以找到这部分的共通性，从而加速这给匹配的过程呢？答案是有的，如果我们能够找到前面相同的这部分的重复点，也就是公共前后缀，我们在指针回溯的时候就可以直接回溯到后缀的下标然后开始匹配，那么时间将会大幅度缩小。\n思路明确，那么我们用一个next数组用来标注每个下标之前公共后缀的起始下标，这样，当我们子串匹配失败时，就可以通过next检索指针回溯的下标，从而达到算法的目的，这就是著名的KMP算法。\n代码如下：\n&#x2F;&#x2F; KMP算法\nvoid getNext(string t, vector&lt;int&gt; &amp;next) &#123;\n    int i &#x3D; 0, j &#x3D; -1;\n    next.resize(t.size());\n    next[0] &#x3D; -1;\n    while (i &lt; t.size() - 1) &#123;\n        if (j &#x3D;&#x3D; -1 || t[i] &#x3D;&#x3D; t[j]) &#123;\n            next[++i] &#x3D; ++j;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n    &#125;\n&#125;\n\nint KMP_Match(string s, string t, int pos) &#123;    &#x2F;&#x2F;s母串，t子串\n    int i &#x3D; pos, j &#x3D; 0;\n    vector&lt;int&gt; next;\n    getNext(t, next);\n    while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;\n        if (s[i] &#x3D;&#x3D; t[j]) &#123;\n            i++; \n            j++;\n        &#125; else &#123;\n            j &#x3D; next[j];\n        &#125;\n        if (j &#x3D;&#x3D; -1) &#123;\n            j++;\n            i++;\n        &#125;\n    &#125;\n    return j &gt;&#x3D; t.size() ? i - t.size() : -1;\n&#125;\n","slug":"KMP","date":"2022-05-07T03:33:21.000Z","categories_index":"","tags_index":"算法","author_index":"Incredible7"}]